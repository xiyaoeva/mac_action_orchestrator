<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Mac Action Orchestrator</title>
  <style>
    :root {
      --bg: #f4efe7;
      --bg-accent: #d9efe1;
      --ink: #182228;
      --muted: #4f5e63;
      --panel: #fffdf9;
      --line: #d9d2c7;
      --brand: #0d8d63;
      --brand-ink: #ffffff;
      --mono: "IBM Plex Mono", Menlo, Consolas, monospace;
      --sans: "Space Grotesk", "Avenir Next", "Segoe UI", sans-serif;
    }

    * { box-sizing: border-box; }

    body {
      margin: 0;
      color: var(--ink);
      font-family: var(--sans);
      background:
        radial-gradient(1200px 520px at 0% 0%, var(--bg-accent), transparent 60%),
        radial-gradient(1000px 440px at 100% 20%, #f8dcc5, transparent 60%),
        var(--bg);
    }

    .shell {
      max-width: 1200px;
      margin: 0 auto;
      padding: 28px 18px 40px;
    }

    .hero {
      border: 1px solid var(--line);
      border-radius: 20px;
      background: linear-gradient(135deg, #fffaf2 0%, #f6fff8 100%);
      padding: 20px;
      margin-bottom: 16px;
      box-shadow: 0 10px 22px rgba(24, 34, 40, 0.08);
    }

    .hero h1 {
      margin: 0;
      font-size: 32px;
      line-height: 1.15;
      letter-spacing: 0.3px;
    }

    .hero p {
      margin: 10px 0 0;
      color: var(--muted);
      max-width: 900px;
      line-height: 1.5;
    }

    .chips {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      margin-top: 14px;
    }

    .chip {
      border: 1px solid #b9d8c8;
      background: #ecfbf3;
      color: #21543f;
      border-radius: 999px;
      padding: 6px 10px;
      font-size: 12px;
      font-weight: 700;
      letter-spacing: 0.2px;
    }

    .grid-top {
      display: grid;
      grid-template-columns: 1fr 1.35fr;
      gap: 16px;
      margin-bottom: 16px;
    }

    .grid-bottom {
      display: grid;
      grid-template-columns: 1.2fr 1fr;
      gap: 16px;
    }

    .panel {
      border: 1px solid var(--line);
      border-radius: 16px;
      background: var(--panel);
      padding: 14px;
      box-shadow: 0 6px 18px rgba(24, 34, 40, 0.05);
    }

    h3 {
      margin: 0 0 10px;
      font-size: 19px;
    }

    .sub {
      margin: 0 0 12px;
      color: var(--muted);
      line-height: 1.45;
    }

    label {
      display: block;
      margin: 10px 0 6px;
      font-size: 13px;
      font-weight: 700;
      color: #2a393f;
    }

    textarea, input {
      width: 100%;
      border-radius: 10px;
      border: 1px solid #c8d0d3;
      padding: 10px;
      font-family: var(--mono);
      background: #ffffff;
      color: #1e2a2f;
    }

    textarea {
      line-height: 1.45;
      resize: vertical;
    }

    .inline {
      display: flex;
      align-items: center;
      gap: 10px;
      flex-wrap: wrap;
    }

    .compact {
      width: 120px;
    }

    button {
      border: 0;
      border-radius: 10px;
      padding: 10px 14px;
      font-family: var(--sans);
      font-weight: 700;
      cursor: pointer;
      background: #dfe8ec;
      color: #23343a;
    }

    .run-btn {
      width: 100%;
      background: linear-gradient(135deg, #11a36f 0%, #0f825a 100%);
      color: var(--brand-ink);
      padding: 12px 14px;
      font-size: 15px;
      letter-spacing: 0.2px;
    }

    .run-btn[disabled] {
      opacity: 0.6;
      cursor: not-allowed;
      filter: grayscale(0.2);
    }

    .stop-btn {
      width: 100%;
      background: #b6423f;
      color: #fff8f8;
      margin-top: 8px;
      padding: 12px 14px;
      font-size: 15px;
      letter-spacing: 0.2px;
    }

    .stop-btn[disabled] {
      opacity: 0.6;
      cursor: not-allowed;
      filter: grayscale(0.2);
    }

    .status-pill {
      display: inline-block;
      min-height: 20px;
      padding: 2px 10px;
      border-radius: 999px;
      border: 1px solid #bfd5c9;
      background: #ecfbf3;
      color: #1b5b41;
      font-size: 12px;
      font-weight: 700;
    }

    .hint {
      margin: 10px 0 0;
      color: var(--muted);
      font-size: 13px;
    }

    .result-meta {
      margin-bottom: 8px;
      color: var(--muted);
      font-size: 13px;
      line-height: 1.4;
    }

    .meta-label {
      color: #30464e;
      font-weight: 700;
    }

    pre {
      margin: 0;
      background: #131e24;
      color: #d4eff9;
      padding: 12px;
      border-radius: 12px;
      border: 1px solid #2f434d;
      overflow-x: auto;
      font-family: var(--mono);
      font-size: 12px;
      min-height: 96px;
      max-height: 260px;
    }

    .log-link {
      color: #0f7a59;
      font-weight: 700;
      text-decoration: none;
      word-break: break-all;
    }

    .log-link:hover {
      text-decoration: underline;
    }

    img {
      width: 100%;
      border: 1px solid #cad6db;
      border-radius: 12px;
      background: #ffffff;
    }

    .resource-list {
      margin: 0;
      padding-left: 18px;
      color: #33484f;
    }

    .resource-list li {
      margin-bottom: 8px;
      line-height: 1.4;
    }

    @media (max-width: 980px) {
      .grid-top,
      .grid-bottom {
        grid-template-columns: 1fr;
      }
    }
  </style>
</head>
<body>
  <main class="shell">
    <section class="hero">
      <h1>Mac Action Orchestrator</h1>
    </section>

    <section class="grid-top">
      <div class="panel">
        <h3>Session Settings</h3>
        <p class="sub">Provide API keys and runtime controls.</p>
        <label for="api-keys">Gemini API Keys</label>
        <textarea id="api-keys" rows="5" placeholder="AIza..."></textarea>
        <div class="inline">
          <div>
            <label for="cooldown">Cooldown (seconds)</label>
            <input class="compact" id="cooldown" type="number" step="0.1" min="0" value="2" />
          </div>
          <div>
            <label for="max-plan-again">Max plan_again</label>
            <input class="compact" id="max-plan-again" type="number" step="1" min="0" value="5" />
          </div>
        </div>
        <div class="inline" style="margin-top:12px;">
          <button onclick="fetchScreenSize()">Get Screen Size</button>
          <span id="screen-size" class="status-pill"></span>
        </div>
      </div>

      <div class="panel">
        <h3>Gemini Planner</h3>
        <p class="sub">Describe the task.</p>
        <label for="plan-prompt">Task Prompt</label>
        <textarea id="plan-prompt" rows="8">Open Chrome, go to https://www.google.com, then type "mac action orchestrator" into the search box and press Enter.</textarea>
        <div style="margin-top:12px;">
          <button id="planner-run-btn" class="run-btn" onclick="runFromPlanner()">Run</button>
          <button id="stop-run-btn" class="stop-btn" onclick="stopRun()" disabled>Stop Run</button>
        </div>
      </div>
    </section>

    <section class="grid-bottom">
      <div class="panel">
        <h3>Run Output</h3>
        <pre id="result">-</pre>
        <div class="result-meta" style="margin-top:10px;">
          <span class="meta-label">Run Log:</span>
          <a class="log-link" id="run-log-link" href="#" target="_blank">-</a>
        </div>
        <pre id="run-log">-</pre>
      </div>

      <div class="panel">
        <h3>Latest Screenshot</h3>
        <img id="shot" src="" alt="(no screenshot yet)" />
        <div class="result-meta" style="margin-top:10px;">
          Local execution is active. SSH/remote flow is intentionally disabled.
        </div>
      </div>
    </section>
  </main>

<script>
let pauseOnPlanAgain = false;
const API_KEYS_STORAGE_KEY = "mao_api_keys";

function togglePausePlanAgain() {
  pauseOnPlanAgain = !pauseOnPlanAgain;
  const btn = document.getElementById("toggle-pause-plan-again");
  if (btn) {
    btn.textContent = pauseOnPlanAgain ? "Pause on plan_again: ON" : "Pause on plan_again: OFF";
  }
}

function readApiKeys() {
  const el = document.getElementById("api-keys");
  if (!el) return [];
  const raw = el.value || "";
  try {
    localStorage.setItem(API_KEYS_STORAGE_KEY, raw);
  } catch (e) {
    // ignore storage errors
  }
  return raw
    .split(/\r?\n/)
    .flatMap((line) => line.split(","))
    .map((line) => line.trim())
    .filter((line) => line && !line.startsWith("#"));
}

function loadApiKeys() {
  const el = document.getElementById("api-keys");
  if (!el) return;
  try {
    const saved = localStorage.getItem(API_KEYS_STORAGE_KEY);
    if (saved) {
      el.value = saved;
    }
  } catch (e) {
    // ignore storage errors
  }
}

async function runAction() {
  const txt = document.getElementById("action").value;
  let payload;
  try { payload = JSON.parse(txt); } catch(e) {
    alert("Invalid JSON"); return;
  }
  const cooldown = readCooldown();
  const url = cooldown === null ? "/api/run_action" : ("/api/run_action?cooldown_seconds=" + cooldown);
  const res = await fetch(url, {
    method: "POST",
    headers: {"Content-Type":"application/json"},
    body: JSON.stringify(payload)
  });
  const data = await res.json();
  document.getElementById("result").textContent = JSON.stringify(data, null, 2);
  updateLatestTabUrl(data);
  if (data.screenshot_url) {
    document.getElementById("shot").src = data.screenshot_url + "?t=" + Date.now();
  }
}

async function capture() {
  const res = await fetch("/api/capture", {method: "POST"});
  const data = await res.json();
  document.getElementById("result").textContent = JSON.stringify(data, null, 2);
  updateLatestTabUrl(data);
  if (data.screenshot_url) {
    document.getElementById("shot").src = data.screenshot_url + "?t=" + Date.now();
  }
}

async function fetchScreenSize() {
  const res = await fetch("/api/screen_size", {method: "POST"});
  const data = await res.json();
  document.getElementById("result").textContent = JSON.stringify(data, null, 2);
  const el = document.getElementById("screen-size");
  if (data.ok && data.width && data.height) {
    el.textContent = `Screen: ${data.width}Ã—${data.height}`;
  } else {
    el.textContent = "";
  }
}

window.addEventListener("load", () => {
  fetchScreenSize();
  loadApiKeys();
});

async function handleActionResponse(data) {
  document.getElementById("result").textContent = JSON.stringify(data, null, 2);
  updateLatestTabUrl(data);
  if (data.log_url) {
    const link = document.getElementById("run-log-link");
    if (link) {
      link.href = data.log_url;
      link.textContent = data.log_url;
    }
    try {
      const logRes = await fetch(data.log_url + "?t=" + Date.now());
      if (logRes.ok) {
        const text = await logRes.text();
        document.getElementById("run-log").textContent = text || "-";
      }
    } catch (e) {
      // ignore log fetch errors
    }
  }
  if (data.screenshot_url) {
    document.getElementById("shot").src = data.screenshot_url + "?t=" + Date.now();
  }
  if (data.paused && data.pause_reason === "plan_again" && data.action && data.action.prompt) {
    await handlePlanAgainPause(data);
  }
  if (data.paused && data.pause_reason === "multi_target") {
    await handleMultiTargetPause(data);
  }
  if (data.paused && data.pause_reason === "occlusion_recovery") {
    await handleOcclusionRecovery(data);
  }
  return data;
}

async function runActionsPayload(payload, mode, logId) {
  const cooldown = readCooldown();
  const maxPlanAgain = readMaxPlanAgain();
  const contextPrompt = readContextPrompt();
  const res = await fetch("/api/run_actions", {
    method: "POST",
    headers: {"Content-Type":"application/json"},
    body: JSON.stringify({
      actions: payload,
      cooldown_seconds: cooldown,
      max_plan_again: maxPlanAgain,
      pause_on_plan_again: pauseOnPlanAgain,
      context_prompt: contextPrompt,
      mode: mode || "local",
      log_id: logId || null,
      api_keys: readApiKeys()
    })
  });
  const data = await res.json();
  return handleActionResponse(data);
}

async function runActionsSequencePayload(batches, mode, logId) {
  const cooldown = readCooldown();
  const maxPlanAgain = readMaxPlanAgain();
  const contextPrompt = readContextPrompt();
  const res = await fetch("/api/run_actions_sequence", {
    method: "POST",
    headers: {"Content-Type":"application/json"},
    body: JSON.stringify({
      batches: batches,
      cooldown_seconds: cooldown,
      max_plan_again: maxPlanAgain,
      pause_on_plan_again: pauseOnPlanAgain,
      context_prompt: contextPrompt,
      mode: mode || "local",
      log_id: logId || null,
      api_keys: readApiKeys()
    })
  });
  const data = await res.json();
  return handleActionResponse(data);
}

function addActionsBox(afterEl, initialValue) {
  const container = document.getElementById("actions-sequence");
  if (!container) return;
  const idx = container.children.length + 1;
  const wrapper = document.createElement("div");
  wrapper.style.marginBottom = "10px";
  wrapper.style.border = "1px solid #eee";
  wrapper.style.borderRadius = "8px";
  wrapper.style.padding = "8px";
  const label = document.createElement("div");
  label.style.display = "flex";
  label.style.alignItems = "center";
  label.style.justifyContent = "space-between";
  const title = document.createElement("div");
  title.textContent = "Batch " + idx;
  const controls = document.createElement("div");
  const addBtn = document.createElement("button");
  addBtn.textContent = "+";
  addBtn.style.marginRight = "6px";
  addBtn.onclick = () => addActionsBox(wrapper);
  const removeBtn = document.createElement("button");
  removeBtn.textContent = "-";
  removeBtn.onclick = () => {
    wrapper.remove();
    renumberBatches();
  };
  controls.appendChild(addBtn);
  controls.appendChild(removeBtn);
  label.appendChild(title);
  label.appendChild(controls);
  const textarea = document.createElement("textarea");
  textarea.className = "actions-item";
  textarea.rows = 6;
  textarea.value = initialValue || `[\n  { "type": "open_url", "url": "https://www.google.com" }\n]`;
  wrapper.appendChild(label);
  wrapper.appendChild(textarea);
  if (afterEl && afterEl.parentNode === container) {
    container.insertBefore(wrapper, afterEl.nextSibling);
  } else {
    container.appendChild(wrapper);
  }
  renumberBatches();
}

function renumberBatches() {
  const container = document.getElementById("actions-sequence");
  if (!container) return;
  Array.from(container.children).forEach((wrapper, index) => {
    const label = wrapper.querySelector("div");
    if (label && label.firstChild) {
      label.firstChild.textContent = "Batch " + (index + 1);
    }
  });
}

async function runActionsSequence(mode) {
  const execMode = mode || "local";
  const logId = "run_" + Date.now() + "_" + Math.random().toString(36).slice(2, 8);
  const items = document.querySelectorAll(".actions-item");
  if (!items.length) {
    alert("Add at least one batch."); return;
  }
  const batches = [];
  for (let i = 0; i < items.length; i++) {
    let payload;
    try { payload = JSON.parse(items[i].value); } catch(e) {
      alert("Invalid JSON in batch " + (i + 1)); return;
    }
    if (!Array.isArray(payload)) {
      alert("Batch " + (i + 1) + " must be a JSON array."); return;
    }
    batches.push(payload);
  }
  const data = await runActionsSequencePayload(batches, execMode, logId);
  if (data && (data.paused || data.ok === false)) {
    return;
  }
}

function readCooldown() {
  const raw = document.getElementById("cooldown").value;
  if (raw === "") { return null; }
  const value = Number(raw);
  if (Number.isNaN(value) || value < 0) { return null; }
  return value;
}

function readMaxPlanAgain() {
  const raw = document.getElementById("max-plan-again").value;
  if (raw === "") { return null; }
  const value = Number(raw);
  if (Number.isNaN(value) || value < 0) { return null; }
  return value;
}

function readContextPrompt() {
  const el = document.getElementById("plan-prompt");
  if (!el) return null;
  const value = el.value.trim();
  return value || null;
}

async function handlePlanAgainPause(data) {
  const prompt = data.action.prompt;
  const confirmRun = confirm(
    "Reached plan_again. Send screenshot + remaining prompt to Gemini to get new actions?"
  );
  if (!confirmRun) {
    return;
  }
  setPlanPromptValue(prompt);
  const res = await fetch("/api/plan_again", {
    method: "POST",
    headers: {"Content-Type":"application/json"},
    body: JSON.stringify({prompt, api_keys: readApiKeys()})
  });
  const planData = await res.json();
  document.getElementById("result").textContent = JSON.stringify(planData, null, 2);
  updateLatestTabUrl(planData);
  if (!planData.ok) {
    alert(planData.error || "plan_again failed.");
    return;
  }
  if (planData.args && Array.isArray(planData.args.batches)) {
    setPlanPromptValue(prompt);
    const logId = "run_" + Date.now() + "_" + Math.random().toString(36).slice(2, 8);
    await runActionsSequencePayload(planData.args.batches, "local", logId);
  }
}

function setPlanPromptValue(value) {
  const el = document.getElementById("plan-prompt");
  if (!el) return;
  if (typeof value !== "string") return;
  el.value = value;
}

async function handleMultiTargetPause(data) {
  if (data.annotated_url) {
    document.getElementById("shot").src = data.annotated_url + "?t=" + Date.now();
  }
  const confirmAsk = confirm(
    "Multiple targets found. Send annotated screenshot to Gemini to choose the correct number?"
  );
  if (!confirmAsk) {
    return;
  }
  const prompt = data.prompt_used || null;
  const res = await fetch("/api/choose_target", {
    method: "POST",
    headers: {"Content-Type":"application/json"},
    body: JSON.stringify({prompt, api_keys: readApiKeys()})
  });
  const chooseData = await res.json();
  document.getElementById("result").textContent = JSON.stringify(chooseData, null, 2);
  updateLatestTabUrl(chooseData);
  if (!chooseData.ok) {
    alert(chooseData.error || "Gemini selection failed.");
    return;
  }
  const index = chooseData.index;
  const confirmRun = confirm(`Gemini chose target #${index}. Execute click?`);
  if (!confirmRun) {
    return;
  }
  const execRes = await fetch("/api/execute_click", {
    method: "POST",
    headers: {"Content-Type":"application/json"},
    body: JSON.stringify({index})
  });
  const execData = await execRes.json();
  document.getElementById("result").textContent = JSON.stringify(execData, null, 2);
  updateLatestTabUrl(execData);
  if (execData.screenshot_url) {
    document.getElementById("shot").src = execData.screenshot_url + "?t=" + Date.now();
  }
}

async function handleOcclusionRecovery(data) {
  if (data.screenshot_url) {
    document.getElementById("shot").src = data.screenshot_url + "?t=" + Date.now();
  }
  const confirmAsk = confirm(
    "Detected occlusion. Ask Gemini how to recover (close tab or open URL) and proceed?"
  );
  if (!confirmAsk) {
    return;
  }
  const chooseData = await resolveOcclusionWithGemini();
  if (!chooseData || !chooseData.ok) {
    return;
  }
  const mode = chooseData.mode;
  const confirmRun = confirm(`Gemini chose "${mode}". Execute recovery now?`);
  if (!confirmRun) {
    return;
  }
  await executeOcclusionMode(mode);
}

async function generatePlan(alreadyRetried) {
  const prompt = document.getElementById("plan-prompt").value.trim();
  if (!prompt) {
    alert("Please enter a prompt."); return;
  }
  const res = await fetch("/api/plan_actions", {
    method: "POST",
    headers: {"Content-Type":"application/json"},
    body: JSON.stringify({prompt, api_keys: readApiKeys()})
  });
  const data = await res.json();
  document.getElementById("result").textContent = JSON.stringify(data, null, 2);
  if (!data.ok && data.error) {
    if (data.error.includes("Missing dependency") || data.error.includes("API key")) {
      alert(data.error);
      return;
    }
  }
  if (!data.ok && data.retryable && !alreadyRetried) {
    alert(data.error + "\n\nInvalid format. Please click Run to retry.");
    return;
  }
  return data;
}

async function preflightPermissions() {
  const res = await fetch("/api/warmup_permissions", {method: "POST"});
  const data = await res.json();
  document.getElementById("result").textContent = JSON.stringify(data, null, 2);
  if (data.ok) {
    return true;
  }
  const missing = Array.isArray(data.missing) ? data.missing : [];
  if (missing.length) {
    const first = missing[0];
    alert(
      `Permission warmup stopped at: ${first.label}\n\n` +
      `Grant permission to Terminal/iTerm for this capability, then click "Run" again.`
    );
  } else {
    alert("Permission warmup failed. Grant required macOS permissions, then click Run again.");
  }
  return false;
}

async function runFromPlanner() {
  const runBtn = document.getElementById("planner-run-btn");
  const stopBtn = document.getElementById("stop-run-btn");
  if (runBtn && runBtn.disabled) {
    return;
  }
  if (runBtn) {
    runBtn.disabled = true;
    runBtn.textContent = "Checking permissions... Please wait";
  }
  if (stopBtn) {
    stopBtn.disabled = true;
    stopBtn.textContent = "Stop Run";
  }
  try {
    const permissionReady = await preflightPermissions();
    if (!permissionReady) {
      return;
    }
    try {
      // After permissions are granted, refresh screen size in UI before execution.
      await fetchScreenSize();
    } catch (e) {
      // Non-blocking: if screen-size refresh fails, still continue run flow.
    }
    if (runBtn) {
      runBtn.textContent = "Start acting... Please wait";
    }
    if (stopBtn) {
      stopBtn.disabled = false;
    }
    const data = await generatePlan();
    if (!data || !data.ok || !data.args || !Array.isArray(data.args.batches)) {
      return;
    }
    const logId = "run_" + Date.now() + "_" + Math.random().toString(36).slice(2, 8);
    await runActionsSequencePayload(data.args.batches, "local", logId);
  } finally {
    if (runBtn) {
      runBtn.disabled = false;
      runBtn.textContent = "Run";
    }
    if (stopBtn) {
      stopBtn.disabled = true;
      stopBtn.textContent = "Stop Run";
    }
  }
}

async function stopRun() {
  const stopBtn = document.getElementById("stop-run-btn");
  const runBtn = document.getElementById("planner-run-btn");
  if (!stopBtn || stopBtn.disabled) {
    return;
  }
  stopBtn.disabled = true;
  stopBtn.textContent = "Stopping...";
  if (runBtn && runBtn.disabled) {
    runBtn.textContent = "Stopping... Please wait";
  }
  try {
    const res = await fetch("/api/stop_run", {method: "POST"});
    const data = await res.json();
    document.getElementById("result").textContent = JSON.stringify(data, null, 2);
  } catch (e) {
    document.getElementById("result").textContent = JSON.stringify({
      ok: false,
      error: String(e)
    }, null, 2);
  }
}

async function findXY() {
  const path = document.getElementById("ocr-path").value.trim();
  const text = document.getElementById("ocr-text").value.trim();
  if (!path || !text) {
    alert("Please provide screenshot path and text."); return;
  }
  const res = await fetch("/api/find_xy", {
    method: "POST",
    headers: {"Content-Type":"application/json"},
    body: JSON.stringify({path, text})
  });
  const data = await res.json();
  document.getElementById("result").textContent = JSON.stringify(data, null, 2);
  updateLatestTabUrl(data);
}

async function annotateTargets() {
  const path = document.getElementById("annotate-path").value.trim();
  const text = document.getElementById("annotate-text").value.trim();
  if (!path || !text) {
    alert("Please provide screenshot path and target text."); return;
  }
  const res = await fetch("/api/annotate_targets", {
    method: "POST",
    headers: {"Content-Type":"application/json"},
    body: JSON.stringify({path, text})
  });
  const data = await res.json();
  document.getElementById("result").textContent = JSON.stringify(data, null, 2);
  updateLatestTabUrl(data);
  if (data.annotated_url) {
    document.getElementById("shot").src = data.annotated_url + "?t=" + Date.now();
  }
}

function setActionsSequence(batches) {
  const container = document.getElementById("actions-sequence");
  if (!container) return;
  container.innerHTML = "";
  batches.forEach((batch) => {
    const value = JSON.stringify(batch, null, 2);
    addActionsBox(null, value);
  });
  renumberBatches();
}

function updateLatestTabUrl(data) {
  if (!data || !("latest_tab_url" in data)) {
    return;
  }
  const el = document.getElementById("latest-tab-url");
  if (!el) return;
  el.textContent = data.latest_tab_url || "-";
}

async function resolveOcclusionWithGemini() {
  const res = await fetch("/api/resolve_occlusion", {
    method: "POST",
    headers: {"Content-Type":"application/json"},
    body: JSON.stringify({api_keys: readApiKeys()})
  });
  const chooseData = await res.json();
  document.getElementById("result").textContent = JSON.stringify(chooseData, null, 2);
  updateLatestTabUrl(chooseData);
  if (!chooseData.ok) {
    alert(chooseData.error || "Occlusion resolution failed.");
    return null;
  }
  return chooseData;
}

async function executeOcclusionMode(mode) {
  if (!mode) {
    alert("No mode selected.");
    return;
  }
  const execRes = await fetch("/api/execute_occlusion", {
    method: "POST",
    headers: {"Content-Type":"application/json"},
    body: JSON.stringify({mode})
  });
  const execData = await execRes.json();
  document.getElementById("result").textContent = JSON.stringify(execData, null, 2);
  updateLatestTabUrl(execData);
  if (!execData.ok) {
    alert(execData.error || "Occlusion execution failed.");
    return;
  }
  return execData;
}

// Sequence editor is hidden in planner-run mode.
</script>
</body>
</html>
